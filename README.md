# linux-shell
Introduction
This code implements a simple shell in C language that can run basic commands like "cd", "exit" , "sleep" , "cat" , ls ,etc.

Compiling and Running
The code can be compiled using the following command:
gcc shell.c -o shell

To run the shell, simply execute the binary file:
./shell

Features
Accepts commands from the user and executes them.
Supports "cd" and "exit" commands.
Runs process as a background process if the command from user ends in & and allows to take commands as input for foreground.
Supports signal handling for the SIGINT signal (generated by the "Control + C" key combination).
the "Control + C" key combination does not exit the shell instead ends the process running in foreground.
Tokenizes the user input based on spaces, tabs, and newlines.
Error handling for incorrect input.
The other c file named shell_e2.c allows user to input commands separated by && and &&& and runns the commands in a serial manner if separated by && otherwise parallely.

Limitations
Only supports basic commands and does not handle more advanced shell features.
Does not handle input and output redirection.
Does not support pipes and other advanced shell operations.

Explanation of Code (shell)
The above code is an implementation of a simple shell program. It provides a command-line interface for the user to interact with the operating system. The shell reads the user input, tokenizes the input string into separate commands and arguments, and then executes the commands.

The code starts with a set of header files being included. The header files contain the function prototypes and data structures used in the program.

The "tokenize" function is used to split the user input into separate tokens, which are then stored in an array of strings. This function takes a string as input, loops through each character in the string, and creates a new token whenever a whitespace character is encountered. The resulting array of tokens is then returned.

The "sigint_handler" function is a signal handler that will be called whenever the program receives a SIGINT signal. This signal is sent to a process when the user presses "Ctrl + C". In this function, the "waitpid" function is used to wait for any child process to terminate, and the process ID and the signal that terminated the process are printed.

The main function of the shell program starts with a call to the "sigaction" function, which sets the "sigint_handler" as the handler for the SIGINT signal.

The shell then enters a loop that reads the user input, tokenizes the input, and executes the commands. The user input is obtained using the "scanf" function, which reads the input until a newline character is encountered.

The code checks if the last token in the array is the character '&', which indicates that the command should run in the background. In this case, the background flag is set to 1, and the '&' token is removed from the array.

If the first token in the array is the string "cd", the shell performs a directory change by calling the "chdir" function. If the "cd" command is not followed by an argument, an error message is printed.

If the first token in the array is the string "exit", the shell terminates by calling the "exit" function.

Otherwise, the shell creates a new child process using the "fork" function. The child process then executes the command using the "execvp" function, which replaces the current process image with the specified command. If the execvp function fails, an error message is printed.

The parent process waits for the child process to terminate, unless the command was run in the background. After the command has been executed, the memory used by the tokens array is freed.

This loop continues until the "exit" command is entered by the user.

Explanation of Code (shell_e2)
This code is implementation os shell. It supports two commands "&&" and "&&&". When a command is followed by "&&", it only executes the next command if the previous one was successful. When a command is followed by "&&&", it executes the next command in the background. The code takes input from the user and tokenizes it by space. Then it splits the input into multiple commands if they are separated by "&&" or "&&&". For each command, it forks a new process and uses execvp() function to execute the command. The execvp() function takes the name of the command and an array of arguments and replaces the current process with the specified command. The parent process waits for the child process to finish if the command was not executed in the background. The code also handles the "exit" command, which exits the shell, and the "cd" command, which changes the current working directory.




